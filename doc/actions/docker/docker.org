#+CATEGORY: ░ SH.WRAP ░
#+FILETAGS: #note sh_wrap
#+OPTIONS: ^:nil toc:nil num:nil author:nil timestamp:nil
#+COLUMNS: %50ITEM TODO %3PRIORITY %Effort %Effort(Effort Children){:} %10CLOCKSUM
#+OPTIONS: H:4 prop:nil d:nil tags:nil p:t c:nil pri:t

#+begin_export markdown
---
title: Docker images and scripts
date: 2022-10-26T05:20:14+03:00
aliases:
  - /docs/dev/actions/docker/docker.md
  - /docs/dev/actions/docker/docker.org
url: /docs/dev/actions/docker/docker.html
tags: ["actions", "development", "docker"]
---
#+end_export

* Common parts                                              :noexport:ignore:
  :PROPERTIES:
  :header-args: :eval no
  :END:

** Elisp

To ensure that tangled files are up to date.
#+name: tangle-dockerfiles
#+begin_src elisp
(org-babel-tangle)
#+end_src

** Bash

Preamble and shell script options.
#+name: preamble
#+begin_src bash
#!/bin/bash
#+end_src

Shell options.
#+name: options
#+begin_src bash
set -o errexit
#+end_src

#+name: options-debug
#+begin_src bash
[[ -v LIVE_DEBUG ]] && set -o xtrace
#+end_src

Gracefully exiting on errors or invalid parameters...
#+name: live-or-die-trap
#+begin_src bash
die() {
	printf "%s: ${LAST_ERROR}\n" "$0" >&2
	exit 1
}

live() {
	true
}

live_or_die=${LIVE_OR_DIE:-die}

LAST_ERROR=
trap '${live_or_die}' ERR
#+end_src

#+name: cd-trap
#+begin_src bash
back() {
	while popd; do :; done 2> /dev/null
	return 0
}

trap 'back' EXIT
#+end_src

Some help.
#+name: help
#+begin_src bash
help() {
	echo "$*" >&2
	exit 1
}
#+end_src

Git configuration clean up.
#+name: git-trap
#+begin_src bash
LAST_ERROR="git config failed"
git_config_backup="$(touch ~/.gitconfig; cat ~/.gitconfig)"

quit-git() {
	cat <<< "${git_config_backup}" > ~/.gitconfig
}

trap 'quit-git' EXIT
#+end_src

Common paths and variables.
#+name: common-variables
#+begin_src bash
export DOCKERFILES_PATH=$(realpath "../../../docker")
export DOCKERFILE_SCRIPTS_PATH="../../../src"
export DOCKER_PATH=$(realpath "../../..")
export DOCKER_REPO="ekotik"
export SOURCE_PATH="../../.."
#+end_src

GH switch.
#+name: gh-mode
#+begin_src bash
gh_mode=0
# shellcheck disable=SC2153
[[ -v GH_MODE ]] && gh_mode=1

gh_echo() {
	local gh_commands

	[[ "${gh_mode}" == 0 ]] && return 0;
	read -d $'\0' -r gh_commands || true;
	echo -en "${gh_commands}\n"
}
#+end_src

Trace.
#+name: xtrace
#+begin_src bash
declare -g xtrace

reset_xtrace() {
	xtrace=$(set -o | grep "xtrace" | grep "on" || true)
	set +o xtrace
}

restore_xtrace()
{
	set "${xtrace:-+}"o xtrace
	set "${xtrace:+-}"o xtrace
	xtrace=
}
#+end_src

* Helper scripts                                            :noexport:ignore:
  :PROPERTIES:
  :header-args: :results output verbatim silent wrap
  :header-args+: :noweb no-export
  :header-args+: :comments none
  :header-args+: :exports code
  :header-args+: :eval never-export
  :END:

** Dockerfile
   :PROPERTIES:
   :header-args:bash: :session *dockerfile*
   :header-args:bash+: :tangle ../../../src/dockerfile.sh
   :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>
#+end_src

Parameters.
#+begin_src bash :tangle no
shift $#
set -- "${DOCKERFILES_PATH}"/test-shellcheck.Dockerfile \
	"${DOCKER_PATH}"/test-shellcheck.Dockerfile
#+end_src

Help and parameters check.
#+begin_src bash
help-dockerfile() {
	printf "Usage: %s: <DOCKERFILE_TEMPLATE> <DOCKERFILE>\n" "$0"
	help "$@"
}

# check dockerfile
if [[ $# -eq 0 ]]; then
	echo >&2 "No dockerfile template specified"
	help-dockerfile "$@"
fi

# check output dockerfile
if [[ $# -eq 1 ]]; then
	echo >&2 "No output dockerfile path specified"
	help-dockerfile "$@"
fi

dockerfile_template=$(realpath "$1")
dockerfile=$(realpath "$2")
#+end_src

#+begin_src bash
LAST_ERROR="dockerfile template and output dockerfile are the same file"
[[ "${dockerfile_template}" != "${dockerfile}" ]] || $live_or_die

LAST_ERROR="no dockerfile template '${dockerfile_template}' found"
[[ -f "${dockerfile_template}" ]] || $live_or_die

env envsubst < "${dockerfile_template}" > "${dockerfile}"
#+end_src

Exit.
#+begin_src bash :eval no
exit 0
#+end_src

** Entrypoint
   :PROPERTIES:
   :header-args:bash: :session *entrypoint*
   :header-args:bash+: :tangle ../../../src/entrypoint.sh
   :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>
#+end_src

#+begin_src bash
<<help>>
#+end_src

Parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}" "${SOURCE_PATH}"/src/test-shellcheck.sh src test
#+end_src

Help and parameters check.
#+begin_src bash
help-entrypoint() {
	printf "Usage: %s: <WORK_DIR> <SCRIPT> [ARGS...]\n" "$0"
	help "$@"
}

# check working directory
if [[ $# -eq 0 ]]; then
	echo >&2 "No working directory specified"
	help-entrypoint "$@"
elif [[ $# -eq 1 ]]; then
	echo >&2 "No script specified"
	help-entrypoint "$@"
fi

work_dir=$(realpath "$1")
script="$2"
shift 2
#+end_src

#+begin_src bash
cd "${work_dir}"
bash "${script}" "$@"
#+end_src

** Test workflows
   :PROPERTIES:
   :header-args:bash: :session *test-workflows*
   :header-args:bash+: :tangle ../../../test/workflow/test-workflows.sh
   :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash :eval no
<<help>>

<<live-or-die-trap>>

<<gh-mode>>

<<xtrace>>
#+end_src

Parameters.
#+begin_src bash :tangle no
shift $#
set -- "ekotik/sh.wrap" "${SOURCE_PATH}"/test/workflow/data/test-shellcheck
#+end_src

Help and parameters check.
#+begin_src bash
help-test-workflows() {
	printf "Usage: %s: <GITHUB_REPO> <DATA_DIRS...>\n" "$0"
	help "$@"
}

# check github repository (OWNER/REPO format)
if [[ $# -eq 0 ]]; then
	echo >&2 "No github repository specified"
	help-test-workflows "$@"
fi
github_repo="$1"
shift 1

# check data directories
if [[ $# -eq 0 ]]; then
	echo >&2 "No data directories specified"
	help-test-workflows "$@"
fi
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

#+begin_src bash :eval no :padline no
reset_xtrace
gh_token="${GITHUB_TOKEN}"
restore_xtrace
#+end_src

#+begin_src bash
# check paths
LAST_ERROR="authentication token is empty"
reset_xtrace
[[ -n "${gh_token}" ]] || $live_or_die
restore_xtrace
#+end_src

#+begin_src bash
# fill in data directories
declare -a data_dirs
if [[ "${gh_mode}" == 1 ]]; then
	readarray -t -d $'\n' data_dirs < <(echo -e "$@")
else
	data_dirs+=("$@")
fi
#+end_src

#+begin_src bash
function test_workflow()
{
	local data_template="$1"
	local datafile="$2"
	# shellcheck disable=SC1090
	source "${datafile}"
	local API_WORKFLOW_DISPATCH="https://api.github.com/repos/${github_repo}/actions/workflows/${WORKFLOW_ID}/dispatches"
	LAST_ERROR="${data_template} (${datafile}): test dispatch failed"
	env envsubst < "${data_template}" | \
		jq '{ ref: .ref, inputs: { run_id: .inputs.run_id, payload: (.inputs.payload | tostring) }}' | \
		curl -X POST "${API_WORKFLOW_DISPATCH}" --fail \
			 -H "Authorization: Bearer ${gh_token}" \
			 -H "Accept: application/vnd.github+json" \
			 -d @- || $live_or_die
}
#+end_src

#+begin_src bash
data_templates=()
for data_dir in "${data_dirs[@]}"; do
	while IFS=$'\0' read -d $'\0' -r data_template; do
		data_templates+=("${data_template}")
	done < <(find "${data_dir}" -name '*.json' -print0)
done
#+end_src

#+begin_src bash
for data_template in "${data_templates[@]}"; do
	data_path="${data_template%.json}"
	while IFS=$'\0' read -d $'\0' -r datafile; do
		test_workflow "${data_template}" "${datafile}"
	done < <(find "${data_path}" -name '*.sh' -print0)
done
#+end_src

Exit.
#+begin_src bash :eval no
exit 0
#+end_src

* Docker image for shellcheck
  :PROPERTIES:
  :header-args: :results output verbatim silent wrap
  :header-args+: :noweb no-export
  :header-args+: :comments none
  :header-args+: :exports code
  :header-args+: :eval never-export
  :header-args:bash: :session *dockerfile-test-shellcheck*
  :END:

#+call: tangle-dockerfiles()

** Build docker image

#+begin_src bash
<<common-variables>>
#+end_src

#+name: dockerfile-test
#+begin_src bash
DOCKERFILE_TEMPLATE="${DOCKERFILES_PATH}"/test-shellcheck.Dockerfile
DOCKER_IMAGE="shwrap:test-shellcheck"
DOCKER_PATH="${DOCKER_PATH}"
DOCKERFILE="${DOCKER_PATH}"/test-shellcheck.Dockerfile
#+end_src

`ubuntu:latest` with `shellcheck` is a base image to run tests for sh.wrap.

#+begin_src dockerfile :tangle ../../../docker/test-shellcheck.Dockerfile :eval no
FROM ubuntu:latest as build

RUN apt update && apt install --yes ca-certificates
RUN apt install --yes bash
RUN apt install --yes shellcheck

FROM build

COPY "${DOCKERFILE_SCRIPTS_PATH}"/entrypoint.sh entrypoint.sh

ENTRYPOINT ["bash", "/entrypoint.sh"]
CMD ["${WORK_DIR}", "${SCRIPT}", "${ARGS}"]
#+end_src

#+begin_src bash
env -i \
    DOCKERFILE_SCRIPTS_PATH="${DOCKERFILE_SCRIPTS_PATH}" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/dockerfile.sh "${DOCKERFILE_TEMPLATE}" "${DOCKERFILE}"
#+end_src

Build and tag an image.
#+name: build
#+begin_src bash :results code
docker build -t "${DOCKER_IMAGE}" -f "${DOCKERFILE}" "${DOCKER_PATH}" --no-cache
docker tag "${DOCKER_IMAGE}" "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

Push to Docker Hub (optionally).
#+begin_src bash :eval query
docker push "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

** Shellcheck runner
   :PROPERTIES:
   :header-args:bash+: :tangle ../../../src/test-shellcheck.sh
   :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :tangle no
LIVE_OR_DIE=live
LIVE_DEBUG=1
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>

<<gh-mode>>
#+end_src

Help.
#+begin_src bash
help-test() {
	printf "Usage: %s: <DIRS...>" "$0"
	help echo "$@"
}

# greetings for github runner
echo '::notice::Shellcheck action started!' | gh_echo
#+end_src

Set up parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}"/test
#+end_src

Check parameters.
#+begin_src bash
if [[ $# -eq 0 ]]; then
	echo >&2 "No source directories specified"
	help-test "$@"
fi

declare -a dirs
if [[ "${gh_mode}" == 1 ]]; then
	readarray -t -d $'\n' dirs < <(echo -e "$@")
else
	dirs+=("$@")
fi
#+end_src

#+begin_src bash
echo '::group::Shellcheck action' | gh_echo
#+end_src

Scan for shell scripts.
#+begin_src bash
# scan for `sh` files in specified directories
files=()

for src_dir in "${dirs[@]}"; do
	while IFS=$'\0' read -d $'\0' -r src_file; do
		files+=("${src_file}")
	done < <(find ./"${src_dir}" -name '*.sh' -print0)
done
#+end_src

Shellcheck run.
#+begin_src bash
# run shellcheck
LAST_ERROR="no shell scripts for checking are found"
[[ "${#files[@]}" != 0 ]] || $live_or_die
{
	ret=$( shellcheck -x -f gcc "${files[@]}" >&3
		   echo $? );
} 3>&1
#+end_src

#+begin_src bash
echo '::endgroup::' | gh_echo
#+end_src

#+begin_src bash
if [[ $ret != 0 ]]; then
	echo '::error::Shellcheck failed' | gh_echo
else
	echo '::notice::Shellcheck passed' | gh_echo
fi

# goodbye
echo '::notice::Shellcheck action ended!' | gh_echo
#+end_src

#+begin_src bash :eval no
#shellcheck disable=SC2086
exit $ret
#+end_src

** Run

#+begin_src bash
<<common-variables>>
<<dockerfile-test>>
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

*** Run script

#+begin_src bash
script="${DOCKERFILE_SCRIPTS_PATH}"/test-shellcheck.sh
args=("${SOURCE_PATH}"/test "${SOURCE_PATH}"/src)
#+end_src

#+begin_src bash :eval query
env -i LIVE_DEBUG=1 \
	bash "${script}" ${args}
#+end_src

#+begin_src bash :eval query
env -i LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
	bash "${script}" "$(printf '%s\n' "${args[@]}")"
#+end_src

*** Run docker

#+begin_src bash
work_dir="/github/workspace"
script="${work_dir}"/src/test-shellcheck.sh
args="test"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-test \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${args}"
#+end_src

#+begin_src bash
args=(test src)
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-test \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 -eLIVE_OR_DIE=live -eGH_MODE=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "$(printf '%s\n' "${args}")"
#+end_src

*** Run action

**** Template

#+begin_src json :tangle ../../../test/workflow/data/test-shellcheck/01.json
{
  "ref": "${REF}",
  "inputs":
  {
    "run_id": "${RUN_ID}",
    "payload":
    {
      "dockerfile_template": "${DOCKERFILE_TEMPLATE}",
      "dockerfile": "${DOCKERFILE}",
      "work_dir": "${WORK_DIR}",
      "script": "${SCRIPT}",
      "args": "${ARGS}"
    }
  }
}
#+end_src

**** Data

#+begin_src bash :tangle ../../../test/workflow/data/test-shellcheck/01/01.sh
#!/bin/bash
# shellcheck disable=SC2034

export WORKFLOW_ID="44983464"
export REF="actions"
export RUN_ID="test-shellcheck/01/01"
export DOCKERFILE_TEMPLATE="./_actions/docker/test-shellcheck.Dockerfile"
export DOCKERFILE="test-shellcheck.Dockerfile"
export WORK_DIR="/github/workspace/_actions"
export SCRIPT="./src/test-shellcheck.sh"
export ARGS="./src"
#+end_src

**** Test

#+begin_src bash
GITHUB_REPO="ekotik/sh.wrap"
env -i GITHUB_TOKEN="${gh_token}" \
    bash "${SOURCE_PATH}"/test/workflow/test-workflows.sh "${GITHUB_REPO}" "${SOURCE_PATH}"/test/workflow/data/test-shellcheck
#+end_src

* Docker image for go build
  :PROPERTIES:
  :header-args: :results output verbatim silent wrap
  :header-args+: :noweb no-export
  :header-args+: :comments none
  :header-args+: :exports code
  :header-args+: :eval never-export
  :header-args:bash: :session *dockerfile-go-build*
  :END:

#+call: tangle-dockerfiles()

** Build docker image

#+begin_src bash
<<common-variables>>
#+end_src

#+name: dockerfile-go-build
#+begin_src bash
DOCKERFILE_TEMPLATE="${DOCKERFILES_PATH}"/go-build.Dockerfile
DOCKER_IMAGE="shwrap:go-build"
DOCKER_PATH="${DOCKER_PATH}"
DOCKERFILE="${DOCKER_PATH}"/go-build.Dockerfile
#+end_src

#+begin_src dockerfile :tangle ../../../docker/go-build.Dockerfile :eval no
FROM ubuntu:latest as build

RUN apt update && apt install --yes ca-certificates
RUN apt install --yes bash
RUN apt install --yes git
RUN apt install --yes golang
RUN apt install --yes make

FROM build as hugo-build

COPY "${DOCKERFILE_SCRIPTS_PATH}"/entrypoint.sh /entrypoint.sh

ENTRYPOINT ["bash", "/entrypoint.sh"]
CMD ["${WORK_DIR}", "${SCRIPT}", "${GIT_PATH}", "${GIT_REPO}", "${ARGS}"]
#+end_src

#+begin_src bash
env -i \
    DOCKERFILE_SCRIPTS_PATH="${DOCKERFILE_SCRIPTS_PATH}" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/dockerfile.sh "${DOCKERFILE_TEMPLATE}" "${DOCKERFILE}"
#+end_src

#+begin_src bash :results code
docker build -t "${DOCKER_IMAGE}" -f "${DOCKERFILE}" "${DOCKER_PATH}" --no-cache
docker tag "${DOCKER_IMAGE}" "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

Push to Docker Hub (optionally).

#+begin_src bash :eval query
docker push "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

** Go build
  :PROPERTIES:
  :header-args:bash+: :tangle ../../../src/go-build.sh
  :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :tangle no
LIVE_OR_DIE=live
LIVE_DEBUG=1
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>

<<git-trap>>

<<cd-trap>>

<<gh-mode>>
#+end_src

Help.
#+begin_src bash
help-go-build() {
	printf "Usage: %s: <GIT_PATH> <GIT_REPO> <GIT_HASH> [BUILD_ARGS...]\n" "$0"
	help "$@"
}

# greetings for github runner
echo '::notice::Go build action started!' | gh_echo
#+end_src

Set up parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}" "https://github.com/gohugoio/hugo" \
	"bfebd8c02cfc0d4e4786e0f64932d832d3976e92" "--tags" "extended"
#+end_src

Check parameters.
#+begin_src bash
# check parameters
if [[ $# -eq 0 ]]; then
	echo >&2 "No git repository destination specified"
	help-go-build "$@"
fi

if [[ $# -eq 1 ]]; then
	echo >&2 "No git repository url specified"
	help-go-build "$@"
fi

if [[ $# -eq 2 ]]; then
	echo >&2 "No git commit hash specified"
	help-go-build "$@"
fi

# check working directory
git_path=$(realpath "$1")
git_repo="$2"
git_hash="$3"
shift 3

declare -a build_args
if [[ "${gh_mode}" == 1 ]]; then
	readarray -t -d $'\n' build_args < <(echo -e "$@")
else
	build_args+=("$@")
fi
#+end_src

#+begin_src bash
LAST_ERROR="working directory is invalid"
[[ -d "${git_path}" ]] || $live_or_die
#+end_src

Set up parameters.
#+begin_src bash
git_repo_dir=$(realpath "${git_path}"/"${git_repo##*/}")
export GOPATH="${git_repo_dir}"/.go
export GOCACHE="${git_repo_dir}"/.cache
#+end_src

Clone and configure repository.
#+begin_src bash
echo '::group::Clone repository' | gh_echo
#+end_src

#+begin_src bash
LAST_ERROR="git repository safe.directory configuration failed"
# fixes go build with -buildvcs option in unsafe git directories
GIT_DIR=.nogit git config --global --add safe.directory "${git_repo_dir}" || $live_or_die

# clone go repo
mkdir -p "${git_repo_dir}" || $live_or_die
git -C "${git_repo_dir}" init || $live_or_die
git -C "${git_repo_dir}" remote add origin "${git_repo}" || $live_or_die
git -C "${git_repo_dir}" pull --depth=1 origin "${git_hash}"
#+end_src

#+begin_src bash
echo '::endgroup::' | gh_echo
#+end_src

Build go binary.
#+begin_src bash
echo '::group::Build go binary' | gh_echo
#+end_src

#+begin_src bash
# build hugo
LAST_ERROR="change directory to '${git_repo_dir}' failed"
pushd "${git_repo_dir}" || $live_or_die

LAST_ERROR="go build failed"
{
	if [[ -f Makefile ]]; then
		make -k -B
	else
		go build -ldflags "-s -w" "${build_args[@]}"
	fi
} || $live_or_die

popd
#+end_src

#+begin_src bash
echo '::endgroup::' | gh_echo
#+end_src

#+begin_src bash
# goodbye
echo '::notice::Go build action ended!' | gh_echo
#+end_src

** Run

#+begin_src bash
<<common-variables>>
<<dockerfile-go-build>>
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

*** Run hugo build

**** Run script

#+begin_src bash
script="${DOCKERFILE_SCRIPTS_PATH}"/go-build.sh
git_path="${SOURCE_PATH}"
git_repo="https://github.com/gohugoio/hugo"
git_hash="bfebd8c02cfc0d4e4786e0f64932d832d3976e92"
build_args=(--tags extended)
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 \
    bash "${script}" "${git_path}" "${git_repo}" "${git_hash}" $(echo "${build_args[@]}")
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
    bash "${script}" "${git_path}" "${git_repo}" "${git_hash}" "$(printf '%s\n' "${build_args[@]}")"
#+end_src

**** Run docker

#+begin_src bash
work_dir="/github/workspace"
script="${work_dir}"/src/go-build.sh
git_path="${work_dir}"/docker
git_repo="https://github.com/gohugoio/hugo"
git_hash="bfebd8c02cfc0d4e4786e0f64932d832d3976e92"
build_args=(--tags extended)
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-hugo-build \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${git_path}" "${git_repo}" "${git_hash}" $(echo "${build_args[@]}")
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-hugo-build \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 -eLIVE_OR_DIE=live -eGH_MODE=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${git_path}" "${git_repo}" "${git_hash}" "$(printf '%s\n' "${build_args[@]}")"
#+end_src

*** Run gh build

**** Run script

#+begin_src bash
script="${DOCKERFILE_SCRIPTS_PATH}"/go-build.sh
git_path="${SOURCE_PATH}"
git_repo="https://github.com/cli/cli"
git_hash="7d71f807c48600d0d8d9f393ef13387504987f1d"
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 \
    bash "${script}" "${git_path}" "${git_repo}" "${git_hash}"
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
    bash "${script}" "${git_path}" "${git_repo}" "${git_hash}"
#+end_src

**** Run docker

#+begin_src bash
work_dir="/github/workspace"
script="${work_dir}"/src/go-build.sh
git_path="${work_dir}"/docker
git_repo="https://github.com/cli/cli"
git_hash="7d71f807c48600d0d8d9f393ef13387504987f1d"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-hugo-build \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${git_path}" "${git_repo}" "${git_hash}" $(echo "${build_args[@]}")
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-hugo-build \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 -eLIVE_OR_DIE=live -eGH_MODE=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${git_path}" "${git_repo}" "${git_hash}" "$(printf '%s\n' "${build_args[@]}")"
#+end_src

**** Run action

***** Template

#+begin_src json :tangle ../../../test/workflow/data/go-build/01.json
{
  "ref": "${REF}",
  "inputs":
  {
    "run_id": "${RUN_ID}",
    "payload":
    {
      "dockerfile_template": "${DOCKERFILE_TEMPLATE}",
      "dockerfile": "${DOCKERFILE}",
      "work_dir": "${WORK_DIR}",
      "script": "${SCRIPT}",
      "git_path": "${GIT_PATH}",
      "git_repo": "${GIT_REPO}",
      "git_hash": "${GIT_HASH}",
      "build_args": "${BUILD_ARGS}",
      "go_bin": "${GO_BIN}",
      "use_cache": ${USE_CACHE}
    }
  }
}
#+end_src

***** Data

#+begin_src bash :tangle ../../../test/workflow/data/go-build/01/01.sh
#!/bin/bash
# shellcheck disable=SC2034

export WORKFLOW_ID="38942439"
export REF="actions"
export RUN_ID="go-build/01/01"
export DOCKERFILE_TEMPLATE="./_actions/docker/go-build.Dockerfile"
export DOCKERFILE="go-build.Dockerfile"
export WORK_DIR="/github/workspace"
export SCRIPT="./_actions/src/go-build.sh"
export GIT_PATH="./"
export GIT_REPO="https://github.com/cli/cli"
export GIT_HASH="7d71f807c48600d0d8d9f393ef13387504987f1d"
export BUILD_ARGS=""
export GO_BIN="./cli/bin"
export USE_CACHE=true
#+end_src

***** Test

#+begin_src bash
GITHUB_REPO="ekotik/sh.wrap"
env -i GITHUB_TOKEN="${gh_token}" \
    bash "${SOURCE_PATH}"/test/workflow/test-workflows.sh "${GITHUB_REPO}" "${SOURCE_PATH}"/test/workflow/data/go-build
#+end_src

* Docker image for documentation conversions
  :PROPERTIES:
  :header-args: :results output verbatim silent wrap
  :header-args+: :noweb no-export
  :header-args+: :comments none
  :header-args+: :exports code
  :header-args+: :eval never-export
  :header-args:bash: :session *pandoc-convert*
  :END:

#+call: tangle-dockerfiles()

** Build docker image

#+begin_src bash
<<common-variables>>
#+end_src

#+name: dockerfile-pandoc-convert
#+begin_src bash
DOCKERFILE_TEMPLATE="${DOCKERFILES_PATH}"/pandoc-convert.Dockerfile
DOCKER_IMAGE="shwrap:pandoc-convert"
DOCKER_PATH="${DOCKER_PATH}"
DOCKERFILE="${DOCKER_PATH}"/pandoc-convert.Dockerfile
#+end_src

#+begin_src dockerfile :tangle ../../../docker/pandoc-convert.Dockerfile :eval no
FROM ubuntu:latest as build

RUN apt update && apt install --yes ca-certificates
RUN apt install --yes bash
RUN apt install --yes pandoc

FROM build as pandoc-convert

COPY "${DOCKERFILE_SCRIPTS_PATH}"/entrypoint.sh /entrypoint.sh

ENTRYPOINT ["bash", "/entrypoint.sh"]
CMD ["${WORK_DIR}", "${SCRIPT}", "${ARGS}"]
#+end_src

#+begin_src bash
env -i \
    DOCKERFILE_SCRIPTS_PATH="${DOCKERFILE_SCRIPTS_PATH}" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/dockerfile.sh "${DOCKERFILE_TEMPLATE}" "${DOCKERFILE}"
#+end_src

#+begin_src bash :results code
docker build -t "${DOCKER_IMAGE}" -f "${DOCKERFILE}" "${DOCKER_PATH}" --no-cache
docker tag "${DOCKER_IMAGE}" "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

Push to Docker Hub (optionally).

#+begin_src bash :eval query
docker push "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

** Convert org file to markdown
   :PROPERTIES:
   :header-args:bash: :session *org-to-md*
   :header-args:bash+: :tangle ../../../src/org-to-md.sh
   :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>

<<gh-mode>>
#+end_src

Parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}"/doc "${SOURCE_PATH}"/.doc-out 1
#+end_src

Help and parameters check.
#+begin_src bash
help-org-to-md() {
	printf "Usage: %s: <IN_DIR> <OUT_DIR> [CLEAN]\n" "$0"
	help "$@"
}

# check source directory
if [[ $# -eq 0 ]]; then
	echo >&2 "No source directory specified"
	help-org-to-md "$@"
fi
# check destination directory
if [[ $# -eq 1 ]]; then
	echo >&2 "No destination directory specified"
	help-org-to-md "$@"
fi
#+end_src

#+begin_src bash
in_dir=$(realpath "$1")
out_dir=$(realpath -m "$2")
clean="$3"
#+end_src

Conversion function.
#+name: org-to-md
#+begin_src bash
function org_to_md()
{
	local page="$1"
	local clean="$2"
	local extensions=""
	if [[ "${clean}" == 1 ]]; then
		extensions="-raw_attribute-raw_html-header_attributes-bracketed_spans"
	fi
	extensions+="+hard_line_breaks"
	extensions+="-yaml_metadata_block-pandoc_title_block"
	pandoc -s "${page}" -t markdown"${extensions}" --wrap=none
}
#+end_src

#+begin_src bash
# greetings for github runner
echo '::notice::Pandoc conversion action started!' | gh_echo
#+end_src

Conversion.
#+begin_src bash
# generate documentation
echo '::group::Convert docs' | gh_echo
LAST_ERROR="conversion failed"
while IFS= read -d $'\0' -r path; do
	dir=$(dirname "$(realpath -m -s "${path}" --relative-base "${in_dir}")")
	file=$(basename "${path}")

	mkdir -p "${out_dir}"/"${dir}" || true 2> /dev/null
	org_to_md "${in_dir}"/"${dir}"/"${file}" 1 > "${out_dir}"/"${dir}"/"${file%.org}.md" \
		|| $live_or_die
done < <(find "${in_dir}" -name '*.org' -print0)
echo '::endgroup::' | gh_echo
#+end_src

#+begin_src bash
# goodbye
echo '::notice::Pandoc conversion action ended!' | gh_echo
#+end_src

Exit.
#+begin_src bash :eval no
exit 0
#+end_src

** Run

#+begin_src bash
<<common-variables>>
<<dockerfile-pandoc-convert>>
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

*** Run script

#+begin_src bash
in_dir="${SOURCE_PATH}"/doc
out_dir="${SOURCE_PATH}"/.doc-out
clean=1
#+end_src

**** Convert documentation

#+begin_src bash :eval query
env -i LIVE_DEBUG=1 \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/org-to-md.sh "${in_dir}" "${out_dir}" "${clean}"
#+end_src

#+begin_src bash :eval query
env -i LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/org-to-md.sh "${in_dir}" "${out_dir}" "${clean}"
#+end_src

*** Run docker

#+begin_src bash
work_dir="/github/workspace"
script="${work_dir}"/src/org-to-md.sh
in_dir="${work_dir}"/doc
out_dir="${work_dir}"/.doc-out
clean=1
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-pandoc-convert \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${in_dir}" "${out_dir}" "${pandoc_clean}"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-pandoc-convert \
       --volume "${DOCKER_PATH}":"${work_dir}" \
	   -eLIVE_DEBUG=1 -eLIVE_OR_DIE=live -eGH_MODE=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${in_dir}" "${out_dir}" "${pandoc_clean}"
#+end_src

*** Run action

**** Template

#+begin_src json :tangle ../../../test/workflow/data/pandoc-convert/01.json
{
  "ref": "${REF}",
  "inputs":
  {
    "run_id": "${RUN_ID}",
    "payload":
    {
      "dockerfile_template": "${DOCKERFILE_TEMPLATE}",
      "dockerfile": "${DOCKERFILE}",
      "work_dir": "${WORK_DIR}",
      "script": "${SCRIPT}",
      "in_dir": "${IN_DIR}",
      "out_dir": "${OUT_DIR}",
      "pandoc_clean": "${PANDOC_CLEAN}",
      "out_cache": "${OUT_CACHE}",
      "out_cache_dir": "${OUT_CACHE_DIR}"
    }
  }
}
#+end_src

**** Data

#+begin_src bash :tangle ../../../test/workflow/data/pandoc-convert/01/01.sh
#!/bin/bash
# shellcheck disable=SC2034

export WORKFLOW_ID="39688674"
export REF="actions"
export RUN_ID="pandoc-convert/01/01"
export DOCKERFILE_TEMPLATE="./_actions/docker/pandoc-convert.Dockerfile"
export DOCKERFILE="pandoc-convert.Dockerfile"
export WORK_DIR="/github/workspace"
export SCRIPT="./_actions/src/org-to-md.sh"
export IN_DIR="./test/pandoc-convert"
export OUT_DIR="./.doc-out"
export PANDOC_CLEAN="1"
export OUT_CACHE="pandoc-convert-01-01"
export OUT_CACHE_DIR="./.doc-out"
#+end_src

**** Test

#+begin_src bash
GITHUB_REPO="ekotik/sh.wrap"
env -i GITHUB_TOKEN="${gh_token}" \
    bash "${SOURCE_PATH}"/test/workflow/test-workflows.sh "${GITHUB_REPO}" "${SOURCE_PATH}"/test/workflow/data/pandoc-convert
#+end_src

* Docker image for documentation generation
  :PROPERTIES:
  :header-args: :results output verbatim silent wrap
  :header-args+: :noweb no-export
  :header-args+: :comments none
  :header-args+: :exports code
  :header-args+: :eval never-export
  :header-args:bash: :session *dockerfile-generate-docs*
  :END:

#+call: tangle-dockerfiles()

** Build docker image

#+begin_src bash
<<common-variables>>
#+end_src

#+name: dockerfile-generate-docs
#+begin_src bash
DOCKERFILE_TEMPLATE="${DOCKERFILES_PATH}"/generate-docs.Dockerfile
DOCKER_IMAGE="shwrap:generate-docs"
DOCKER_PATH="${DOCKER_PATH}"
DOCKERFILE="${DOCKER_PATH}"/generate-docs.Dockerfile
#+end_src

#+begin_src dockerfile :tangle ../../../docker/generate-docs.Dockerfile :eval no
FROM ubuntu:latest as build

COPY "${DOCKERFILE_SCRIPTS_PATH}"/entrypoint.sh /entrypoint.sh

ENTRYPOINT ["bash", "/entrypoint.sh"]
CMD ["${WORK_DIR}", "${SCRIPT}", "${ARGS}"]
#+end_src

#+begin_src bash
env -i \
	DOCKERFILE_SCRIPTS_PATH="${DOCKERFILE_SCRIPTS_PATH}" \
	bash "${DOCKERFILE_SCRIPTS_PATH}"/dockerfile.sh "${DOCKERFILE_TEMPLATE}" "${DOCKERFILE}"
#+end_src

#+begin_src bash :results code
docker build -t "${DOCKER_IMAGE}" -f "${DOCKERFILE}" "${DOCKER_PATH}" --no-cache
docker tag "${DOCKER_IMAGE}" "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

Push to Docker Hub (optionally).

#+begin_src bash :eval query
docker push "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

** Generate documentation
   :PROPERTIES:
   :header-args:bash: :session *generate-docs*
   :header-args:bash+: :tangle ../../../src/generate-docs.sh
   :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>

<<gh-mode>>
#+end_src

Parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}"/src "${SOURCE_PATH}"/.devdocs-out
#+end_src

Help and parameters check.
#+begin_src bash
help-generate-docs() {
	printf "Usage: %s: <IN_DIR> <OUT_DIR>\n" "$0"
	help "$@"
}

# check source directory
if [[ $# -eq 0 ]]; then
	echo >&2 "No source directory specified"
	help-generate-docs "$@"
fi
# check destination directory
if [[ $# -eq 1 ]]; then
	echo >&2 "No destination directory specified"
	help-generate-docs "$@"
fi
#+end_src

#+begin_src bash
in_dir=$(realpath "$1")
out_dir=$(realpath -m "$2")
#+end_src

Generate function.
#+name: org-to-md
#+begin_src bash
function generate_docs()
{
	local file="$1"
	grep -rl "^[[:space:]]*##" "${file}" |
		sort --version-sort |
		xargs -n1 grep -h "^[[:space:]]*##" |
		sed 's/^[[:space:]]*//' |
		sed 's/^##[[:space:]]\?//'
}
#+end_src

#+begin_src bash
# greetings for github runner
echo '::notice::Documentation generation action started!' | gh_echo
#+end_src

Conversion.
#+begin_src bash
# generate documentation
echo '::group::Generate docs' | gh_echo
LAST_ERROR="generation failed"
while IFS= read -d $'\0' -r path; do
	dir=$(dirname "$(realpath -m -s "${path}" --relative-base "${in_dir}")")
	file=$(basename "${path}")

	mkdir -p "${out_dir}"/"${dir}" || true 2> /dev/null
	generate_docs "${in_dir}"/"${dir}"/"${file}" > \
				  "${out_dir}"/"${dir}"/"${file}.md" || $live_or_die
done < <(find "${in_dir}" -name '*.sh' -print0)
echo '::endgroup::' | gh_echo
#+end_src

#+begin_src bash
# goodbye
echo '::notice::Documentation generation action ended!' | gh_echo
#+end_src

Exit.
#+begin_src bash :eval no
exit 0
#+end_src

** Run

#+begin_src bash
<<common-variables>>
<<dockerfile-generate-docs>>
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

*** Run script

#+begin_src bash
in_dir="${SOURCE_PATH}"/src
out_dir="${SOURCE_PATH}"/.devdocs-out
#+end_src

**** Generate documentation

#+begin_src bash :eval query
env -i LIVE_DEBUG=1 \
	bash "${DOCKERFILE_SCRIPTS_PATH}"/generate-docs.sh "${in_dir}" "${out_dir}"
#+end_src

#+begin_src bash :eval query
env -i LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
	bash "${DOCKERFILE_SCRIPTS_PATH}"/generate-docs.sh "${in_dir}" "${out_dir}"
#+end_src

*** Run docker

#+begin_src bash
work_dir="/github/workspace"
script="${work_dir}"/src/generate-docs.sh
in_dir="${work_dir}"/src
out_dir="${work_dir}"/.devdocs-out
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-generate-docs \
	   --volume "${DOCKER_PATH}":"${work_dir}" \
	   -eLIVE_DEBUG=1 \
	   "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
	   "${work_dir}" "${script}" "${in_dir}" "${out_dir}"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-generate-docs \
	   --volume "${DOCKER_PATH}":"${work_dir}" \
	   -eLIVE_DEBUG=1 -eLIVE_OR_DIE=live -eGH_MODE=1 \
	   "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
	   "${work_dir}" "${script}" "${in_dir}" "${out_dir}"
#+end_src

*** Run action

**** Template

#+begin_src json :tangle ../../../test/workflow/data/generate-docs/01.json
{
  "ref": "${REF}",
  "inputs":
  {
    "run_id": "${RUN_ID}",
    "payload":
    {
      "dockerfile_template": "${DOCKERFILE_TEMPLATE}",
      "dockerfile": "${DOCKERFILE}",
      "work_dir": "${WORK_DIR}",
      "script": "${SCRIPT}",
      "in_dir": "${IN_DIR}",
      "out_dir": "${OUT_DIR}",
      "out_cache": "${OUT_CACHE}",
      "out_cache_dir": "${OUT_CACHE_DIR}"
    }
  }
}
#+end_src

**** Data

#+begin_src bash :tangle ../../../test/workflow/data/generate-docs/01/01.sh
#!/bin/bash
# shellcheck disable=SC2034

export WORKFLOW_ID="39688674"
export REF="actions"
export RUN_ID="generate-docs/01/01"
export DOCKERFILE_TEMPLATE="./_actions/docker/generate-docs.Dockerfile"
export DOCKERFILE="generate-docs.Dockerfile"
export WORK_DIR="/github/workspace"
export SCRIPT="./_actions/src/generate-docs.sh"
export IN_DIR="./src"
export OUT_DIR="./.devdoc-out"
export OUT_CACHE="generate-docs-01-01"
export OUT_CACHE_DIR="./.devdoc-out"
#+end_src

**** Test

#+begin_src bash
GITHUB_REPO="ekotik/sh.wrap"
env -i GITHUB_TOKEN="${gh_token}" \
	bash "${SOURCE_PATH}"/test/workflow/test-workflows.sh "${GITHUB_REPO}" "${SOURCE_PATH}"/test/workflow/data/pandoc-convert
#+end_src



* Docker image for documentation site
  :PROPERTIES:
  :header-args: :results output verbatim silent wrap
  :header-args+: :noweb no-export
  :header-args+: :comments none
  :header-args+: :exports code
  :header-args+: :eval never-export
  :header-args:bash: :session *dockerfile-hugo-site*
  :END:

#+call: tangle-dockerfiles()

** Build docker image

#+begin_src bash
<<common-variables>>
#+end_src

#+name: dockerfile-hugo-site
#+begin_src bash
DOCKERFILE_TEMPLATE="${DOCKERFILES_PATH}"/hugo-site.Dockerfile
DOCKER_IMAGE="shwrap:hugo-site"
DOCKER_PATH="${DOCKER_PATH}"
DOCKERFILE="${DOCKER_PATH}"/hugo-site.Dockerfile
#+end_src

#+begin_src dockerfile :tangle ../../../docker/hugo-site.Dockerfile :eval no
FROM ubuntu:latest as build

RUN apt update && apt install --yes ca-certificates
RUN apt install --yes bash
RUN apt install --yes curl
RUN apt install --yes git
RUN apt install --yes golang
RUN mkdir /go
COPY "${HUGO_BIN_SOURCE}" "${HUGO_BIN_DEST}"

FROM build as hugo-site

COPY "${DOCKERFILE_SCRIPTS_PATH}"/entrypoint.sh /entrypoint.sh

ENTRYPOINT ["bash", "/entrypoint.sh"]
CMD ["${WORK_DIR}", "${SCRIPT}", "${HUGO_BIN_DEST}", "${DOCS_DIR}", "${SITE_DIR}", "${PUBLIC_DIR}"]
#+end_src

#+begin_src bash
env -i \
    DOCKERFILE_SCRIPTS_PATH="${DOCKERFILE_SCRIPTS_PATH}" \
    HUGO_BIN_SOURCE="./docker/hugo/hugo" \
    HUGO_BIN_DEST="/go/hugo" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/dockerfile.sh "${DOCKERFILE_TEMPLATE}" "${DOCKERFILE}"
#+end_src

#+begin_src bash :results code
docker build -t "${DOCKER_IMAGE}" -f "${DOCKERFILE}" "${DOCKER_PATH}" --no-cache
docker tag "${DOCKER_IMAGE}" "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

Push to Docker Hub (optionally).

#+begin_src bash :eval query
docker push "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

** Hugo site
  :PROPERTIES:
  :header-args:bash+: :tangle ../../../src/hugo-site.sh
  :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :tangle no
LIVE_OR_DIE=live
LIVE_DEBUG=1
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>

<<gh-mode>>
#+end_src

Help.
#+name: help-hugo-site
#+begin_src bash
help-hugo-site() {
	printf "Usage: %s: <HUGO_BIN> <DOCS_DIR> <SITE_DIR> <PUBLIC_DIR>\n" "$0"
	help "$@"
}
#+end_src

#+begin_src bash
# greetings for github runner
echo '::notice::Hugo site action started!' | gh_echo
#+end_src

Set up parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}"/hugo/hugo "${SOURCE_PATH}"/test/hugo-site/site/content \
	"${SOURCE_PATH}"/test/hugo-site/site \
	"${SOURCE_PATH}"/test/hugo-site/site/public
#+end_src

Check parameters.
#+name: check-hugo-site
#+begin_src bash
# check parameters
if [[ $# -eq 0 ]]; then
	echo >&2 "No hugo binary path specified"
	help-hugo-site "$@"
fi

if [[ $# -eq 1 ]]; then
	echo >&2 "No documentation directory specified"
	help-hugo-site "$@"
fi

if [[ $# -eq 2 ]]; then
	echo >&2 "No site directory specified"
	help-hugo-site "$@"
fi

if [[ $# -eq 3 ]]; then
	echo >&2 "No publish directory specified"
	help-hugo-site "$@"
fi

hugo_bin=$(realpath "$1")
docs_dir=$(realpath "$2")
site_dir=$(realpath "$3")
public_dir=$(realpath "$4")
#+end_src

#+begin_src bash
# check paths
LAST_ERROR="hugo binary not found"
[[ -f "${hugo_bin}" ]] || $live_or_die
LAST_ERROR="documentation directory not found"
[[ -d "${site_dir}" ]] || $live_or_die
#+end_src

Hugo run.
#+begin_src bash
# generate documentation
echo '::group::Generate hugo site' | gh_echo
# hugo run
chmod u+x "${hugo_bin}"
{ pushd "${site_dir}"; "${hugo_bin}" mod get -u; popd; } || $live_or_die
"${hugo_bin}" -c "${docs_dir}" -s "${site_dir}" -d "${public_dir}" || $live_or_die
echo '::endgroup::' | gh_echo
#+end_src

#+begin_src bash
# goodbye
echo '::notice::Hugo site action ended!' | gh_echo
#+end_src

*** Docsy site
    :PROPERTIES:
    :header-args:bash+: :tangle ../../../src/docsy-site.sh
    :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :tangle no
LIVE_OR_DIE=live
LIVE_DEBUG=1
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>

<<gh-mode>>
#+end_src

Help.
#+begin_src bash
help-docsy-site() {
	printf "Usage: %s: <HUGO_BIN> <DOCS_DIR> <SITE_DIR> <PUBLIC_DIR>\n" "$0"
	help "$@"
}

<<help-hugo-site>>
#+end_src

#+begin_src bash
# greetings for github runner
echo '::notice::Docsy site export started!' | gh_echo
#+end_src

Set up parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}"/hugo/hugo "${SOURCE_PATH}"/test/docsy-site/site/content \
	"${SOURCE_PATH}"/test/docsy-site/site \
	"${SOURCE_PATH}"/test/docsy-site/site/public
#+end_src

Check parameters.
#+begin_src bash
# check parameters
if [[ $# -eq 0 ]]; then
	echo >&2 "No arguments specified"
	help-docsy-site "$@"
fi

<<check-hugo-site>>

# check environment
env
if [[ -z "${DOCKERFILE_SCRIPTS_PATH}" ]]; then
	echo >&2 "Environment variable 'DOCKERFILE_SCRIPTS_PATH' is not exposed"
	help-docsy-site "$@"
fi
#+end_src

#+begin_src bash
LAST_ERROR="docsy site export failed"
echo '::group::Install docsy theme dependencies' | gh_echo
nvm &> /dev/null || git clone --depth=1 -b v0.39.2 https://github.com/ekotik/nvm ~/.nvm || $live_or_die
# shellcheck disable=SC1090
source ~/.nvm/nvm.sh
nvm use 18 || { nvm install 18; nvm use 18; } || $live_or_die
# get npm modules
pushd "${site_dir}"/themes/docsy
npm install || $live_or_die
popd
npm install --save-dev autoprefixer postcss-cli postcss || $live_or_die
echo '::endgroup::' | gh_echo
#+end_src

Run generation script.
#+begin_src bash
NODE_PATH=$(realpath "./node_modules") bash "${DOCKERFILE_SCRIPTS_PATH}"/hugo-site.sh "${hugo_bin}" "${docs_dir}" "${site_dir}" "${public_dir}"
#+end_src

#+begin_src bash
# goodbye
echo '::notice::Docsy site export ended!' | gh_echo
#+end_src

** Run

#+begin_src bash
<<common-variables>>
<<dockerfile-hugo-site>>
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

*** Run script

#+begin_src bash
hugo_bin="${SOURCE_PATH}"/hugo/hugo
docs_dir="${SOURCE_PATH}"/test/hugo-site/site/content
site_dir="${SOURCE_PATH}"/test/hugo-site/site
public_dir="${site_dir}"/public
#+end_src

**** Hugo

#+begin_src bash :eval query
env -i LIVE_DEBUG=1 \
	bash "${DOCKERFILE_SCRIPTS_PATH}"/hugo-site.sh "${hugo_bin}" "${docs_dir}" "${site_dir}" "${public_dir}"
#+end_src

#+begin_src bash :eval query
env -i LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/hugo-site.sh "${hugo_bin}" "${docs_dir}" "${site_dir}" "${public_dir}"
#+end_src

**** Docsy

#+begin_src bash
hugo_bin="${SOURCE_PATH}"/hugo/hugo
docs_dir="${SOURCE_PATH}"/test/docsy-site/site/content
site_dir="${SOURCE_PATH}"/test/docsy-site/site
public_dir="${site_dir}"/public
#+end_src

#+begin_src bash :eval query
declare -fx nvm
env LIVE_DEBUG=1 \
	DOCKERFILE_SCRIPTS_PATH="${DOCKERFILE_SCRIPTS_PATH}" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/docsy-site.sh "${hugo_bin}" "${docs_dir}" "${site_dir}" "${public_dir}"
#+end_src

#+begin_src bash :eval query
declare -fx nvm
env LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
	DOCKERFILE_SCRIPTS_PATH="${DOCKERFILE_SCRIPTS_PATH}" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/docsy-site.sh "${hugo_bin}" "${docs_dir}" "${site_dir}" "${public_dir}"
#+end_src

*** Run docker

#+begin_src bash
work_dir="/github/workspace"
script="${work_dir}"/src/hugo-site.sh
hugo_bin=/go/hugo
hugo_docs_dir="${work_dir}"/test/hugo-site/site/content
hugo_site_dir="${work_dir}"/test/hugo-site/site
hugo_public_dir="${hugo_site_dir}"/public
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-hugo-site \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${hugo_bin}" "${hugo_docs_dir}" "${hugo_site_dir}" "${hugo_public_dir}"
#+end_src

#+begin_src bash
script="${work_dir}"/src/docsy-site.sh
docsy_docs_dir="${work_dir}"/test/docsy-site/site/content
docsy_site_dir="${work_dir}"/test/docsy-site/site
docsy_public_dir="${docsy_site_dir}"/public
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-hugo-site \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 -eLIVE_OR_DIE=live -eGH_MODE=1 \
	   -eNODE_OPTIONS="--jitless" \
	   -eDOCKERFILE_SCRIPTS_PATH="${work_dir}/src" \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${hugo_bin}" "${docsy_docs_dir}" "${docsy_site_dir}" "${docsy_public_dir}"
#+end_src

*** Run action

**** Template

#+begin_src json :tangle ../../../test/workflow/data/hugo-site/01.json
{
  "ref": "${REF}",
  "inputs":
  {
    "run_id": "${RUN_ID}",
    "payload":
    {
      "dockerfile_template": "${DOCKERFILE_TEMPLATE}",
      "dockerfile": "${DOCKERFILE}",
      "work_dir": "${WORK_DIR}",
      "script": "${SCRIPT}",
      "hugo_bin_source": "${HUGO_BIN_SOURCE}",
      "hugo_bin_dest": "${HUGO_BIN_DEST}",
      "hugo_bin_path": "${HUGO_BIN_PATH}",
      "hugo_repo": "${HUGO_REPO}",
      "hugo_hash": "${HUGO_HASH}",
      "hugo_build_args": "${HUGO_BUILD_ARGS}",
      "docs_dir": "${DOCS_DIR}",
      "site_dir": "${SITE_DIR}",
      "public_dir": "${PUBLIC_DIR}",
      "public_cache": "${PUBLIC_CACHE}"
    }
  }
}
#+end_src

**** Data

#+begin_src bash :tangle ../../../test/workflow/data/hugo-site/01/01.sh
#!/bin/bash
# shellcheck disable=SC2034

export WORKFLOW_ID="38942441"
export REF="actions"
export RUN_ID="hugo-site/01/01"
export DOCKERFILE_TEMPLATE="./_actions/docker/hugo-site.Dockerfile"
export DOCKERFILE="hugo-site.Dockerfile"
export WORK_DIR="/github/workspace"
export SCRIPT="./_actions/src/hugo-site.sh"
export HUGO_BIN_SOURCE="./hugo/hugo"
export HUGO_BIN_DEST="/go/hugo"
export HUGO_BIN_PATH="./hugo"
export HUGO_REPO="https://github.com/gohugoio/hugo"
export HUGO_HASH="bfebd8c02cfc0d4e4786e0f64932d832d3976e92"
export HUGO_BUILD_ARGS="--tags\\nextended"
export DOCS_DIR="./test/hugo-site/site/content"
export SITE_DIR="./test/hugo-site/site"
export PUBLIC_DIR="./_actions/public"
export PUBLIC_CACHE="hugo-site-01-01"
#+end_src

**** Test

#+begin_src bash
GITHUB_REPO="ekotik/sh.wrap"
env -i GITHUB_TOKEN="${gh_token}" \
    bash "${SOURCE_PATH}"/test/workflow/test-workflows.sh "${GITHUB_REPO}" "${SOURCE_PATH}"/test/workflow/data/hugo-site
#+end_src

* Docker image for git tasks
  :PROPERTIES:
  :header-args: :results output verbatim silent wrap
  :header-args+: :noweb no-export
  :header-args+: :comments none
  :header-args+: :exports code
  :header-args+: :eval never-export
  :header-args:bash: :session *dockerfile-git-tasks*
  :END:

#+call: tangle-dockerfiles()

** Build docker image

#+begin_src bash
<<common-variables>>
#+end_src

#+name: dockerfile-git-tasks
#+begin_src bash
DOCKERFILE_TEMPLATE="${DOCKERFILES_PATH}"/git-tasks.Dockerfile
DOCKER_IMAGE="shwrap:git-tasks"
DOCKER_PATH="${DOCKER_PATH}"
DOCKERFILE="${DOCKER_PATH}"/git-tasks.Dockerfile
#+end_src

#+begin_src dockerfile :tangle ../../../docker/git-tasks.Dockerfile :eval no
FROM ubuntu:latest as build

RUN apt update && apt install --yes ca-certificates
RUN apt install --yes bash
RUN apt install --yes curl
RUN apt install --yes gettext
RUN apt install --yes git
RUN apt install --yes jq
RUN mkdir /go
COPY "${GH_BIN_SOURCE}" "${GH_BIN_DEST}"

FROM build as git-tasks

COPY "${DOCKERFILE_SCRIPTS_PATH}"/entrypoint.sh /entrypoint.sh

ENTRYPOINT ["bash", "/entrypoint.sh"]
CMD ["${WORK_DIR}", "${SCRIPT}", "${GH_BIN_DEST}", "${ARGS}"]
#+end_src

#+begin_src bash
env -i \
    DOCKERFILE_SCRIPTS_PATH="${DOCKERFILE_SCRIPTS_PATH}" \
    GH_BIN_SOURCE="./docker/cli/bin/gh" \
    GH_BIN_DEST="/go/gh" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/dockerfile.sh "${DOCKERFILE_TEMPLATE}" "${DOCKERFILE}"
#+end_src

#+begin_src bash :results code
docker build -t "${DOCKER_IMAGE}" -f "${DOCKERFILE}" "${DOCKER_PATH}" --no-cache
docker tag "${DOCKER_IMAGE}" "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

Push to Docker Hub (optionally).

#+begin_src bash :eval query
docker push "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

** Git tasks
   :PROPERTIES:
   :header-args:bash+: :tangle ../../../src/git-tasks.sh
   :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :tangle no
LIVE_OR_DIE=live
LIVE_DEBUG=1
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>

<<gh-mode>>

<<xtrace>>
#+end_src

Help.
#+begin_src bash
help-git-tasks() {
	printf "Usage: %s: <GH_BIN> <GIT_REPO> <GIT_BRANCH> [GIT_COMMANDS...]\n" "$0"
	help "$@"
}

echo '::notice::Git tasks action started!' | gh_echo
#+end_src

Set up parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}"/cli/bin/gh "https://github.com/ekotik/sh.wrap.git" "gh-pages/test" "git status
git log"
#+end_src

Check parameters.
#+begin_src bash
# check parameters
if [[ $# -eq 0 ]]; then
	echo >&2 "No gh binary path specified"
	help-git-tasks "$@"
fi

if [[ $# -eq 1 ]]; then
	echo >&2 "No git repository specified"
	help-git-tasks "$@"
fi

if [[ $# -eq 2 ]]; then
	echo >&2 "No git branch specified"
	help-git-tasks "$@"
fi

gh_bin=$(realpath "$1")
git_repo="$2"
git_branch="$3"
shift 3
git_commands="$*"
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

#+begin_src bash :eval no :padline no
reset_xtrace
gh_token="${GITHUB_TOKEN}"
restore_xtrace
#+end_src

#+begin_src bash
# check paths
LAST_ERROR="gh binary not found"
[[ -f "${gh_bin}" ]] || $live_or_die
# check token
LAST_ERROR="authentication token is empty"
reset_xtrace
[[ -n "${gh_token}" ]] || $live_or_die
restore_xtrace
#+end_src

Authenticate.
#+begin_src bash
# authenticate with token
LAST_ERROR="authentication failed"
chmod u+x "${gh_bin}"
unset GITHUB_TOKEN
GIT_DIR=.nogit "${gh_bin}" auth login --git-protocol https --with-token <<< "${gh_token}" || $live_or_die
GIT_DIR=.nogit "${gh_bin}" auth setup-git || $live_or_die
#+end_src

#+begin_src bash
echo '::group::Git tasks' | gh_echo
#+end_src

Publish to gh-pages (on push event).
#+begin_src bash
# git tasks
if [[ "${GITHUB_EVENT_NAME}" == "push" ]] || [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
	LAST_ERROR="git clone failed"
	git_repo_dir=$(mktemp -u -p "./")
	git clone -b "${git_branch}" "${git_repo}" "${git_repo_dir}" || $live_or_die
	pushd "${git_repo_dir}"
	git config --global --add safe.directory "${git_repo_dir}" || $live_or_die
	git config user.name "git-tasks action"
	git config user.email "nobody@nowhere"
	LAST_ERROR="git tasks failed"
	git_commands_file=$(mktemp -u -p "./")
	echo -e "${git_commands}" > "${git_commands_file}"
	bash "${git_commands_file}"
	popd
fi
#+end_src

#+begin_src bash
echo '::endgroup::' | gh_echo
#+end_src

#+begin_src bash
echo '::notice::Git tasks action ended!' | gh_echo
#+end_src

** GH publish
   :PROPERTIES:
   :header-args:bash+: :tangle ../../../src/gh-publish.sh
   :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :tangle no
LIVE_OR_DIE=live
LIVE_DEBUG=1
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>

<<gh-mode>>

<<xtrace>>
#+end_src

Help.
#+begin_src bash
help-gh-publish() {
	printf "Usage: %s: <GH_BIN> <GH_PAGES_REPO> <GH_PAGES_BRANCH> <PUBLIC_DIR>\n" "$0"
	help "$@"
}

echo '::notice::GH publish action started!' | gh_echo
#+end_src

Set up parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}"/cli/bin/gh "https://github.com/ekotik/sh.wrap.git" \
	"gh-pages/test" "${SOURCE_PATH}"/test/hugo-site/site/public
#+end_src

Check parameters.
#+begin_src bash :eval no
# check parameters
if [[ $# -eq 0 ]]; then
	echo >&2 "No gh binary path specified"
	help-gh-publish "$@"
fi

if [[ $# -eq 1 ]]; then
	echo >&2 "No gh-pages repository specified"
	help-gh-publish "$@"
fi

if [[ $# -eq 2 ]]; then
	echo >&2 "No gh-pages branch specified"
	help-gh-publish "$@"
fi

if [[ $# -eq 3 ]]; then
	echo >&2 "No publish directory specified"
	help-gh-publish "$@"
fi

gh_bin=$(realpath "$1")
gh_pages_repo="$2"
gh_pages_branch="$3"
public_dir=$(realpath "$4")
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

#+begin_src bash :eval no :padline no
reset_xtrace
gh_token="${GITHUB_TOKEN}"
restore_xtrace
#+end_src

#+begin_src bash
# check paths
LAST_ERROR="gh binary not found"
[[ -f "${gh_bin}" ]] || $live_or_die
LAST_ERROR="publish directory not found"
[[ -d "${public_dir}" ]] || $live_or_die
# check token
LAST_ERROR="authentication token is empty"
reset_xtrace
[[ -n "${gh_token}" ]] || $live_or_die
restore_xtrace
#+end_src

Authenticate.
#+begin_src bash
# authenticate with token
LAST_ERROR="authentication failed"
chmod u+x "${gh_bin}"
unset GITHUB_TOKEN
GIT_DIR=.nogit "${gh_bin}" auth login --git-protocol https --with-token <<< "${gh_token}" || $live_or_die
GIT_DIR=.nogit "${gh_bin}" auth setup-git || $live_or_die
#+end_src

#+begin_src bash
echo '::group::Push site to GH pages' | gh_echo
#+end_src

Publish to gh-pages (on push event).
#+begin_src bash
# publish site
if [[ "${GITHUB_EVENT_NAME}" == "push" ]] || [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
	LAST_ERROR="publish site failed"
	pushd "${public_dir}"
	git init
	git config --global --add safe.directory "${public_dir}" || $live_or_die
	git config user.name "gh-publish action"
	git config user.email "nobody@nowhere"
	git checkout -b "${gh_pages_branch}" || $live_or_die
	git remote add -t "${gh_pages_branch}" "origin" "${gh_pages_repo}" || $live_or_die
	git add .
	git commit --allow-empty -m "pages: update gh pages" \
		--author="gh-publish action <nobody@nowhere>" || $live_or_die
	git push "origin" "${gh_pages_branch}" --force || $live_or_die
	popd
fi
#+end_src

#+begin_src bash
echo '::endgroup::' | gh_echo
#+end_src

#+begin_src bash
echo '::notice::GH publish action ended!' | gh_echo
#+end_src

** Git submodules update
   :PROPERTIES:
   :header-args:bash+: :tangle ../../../src/update-submodules.sh
   :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :tangle no
LIVE_OR_DIE=live
LIVE_DEBUG=1
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>

<<gh-mode>>

<<xtrace>>
#+end_src

Help.
#+begin_src bash
help-git-submodule() {
	printf "Usage: %s: <GH_BIN> <GIT_REPO> <GIT_BRANCH> <GIT_REPO_DIR> [GIT_AMEND]\n" "$0"
	help "$@"
}

echo '::notice::git submodules update started!' | gh_echo
#+end_src

Set up parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}"/cli/bin/gh "https://github.com/ekotik/sh.wrap.git" \
	"gh-pages/test" "./update-submodules"
#+end_src

Check parameters.
#+begin_src bash :eval no
# check parameters
if [[ $# -eq 0 ]]; then
	echo >&2 "No gh binary path specified"
	help-git-submodule "$@"
fi

if [[ $# -eq 1 ]]; then
	echo >&2 "No git repository specified"
	help-git-submodule "$@"
fi

if [[ $# -eq 2 ]]; then
	echo >&2 "No git branch specified"
	help-git-submodule "$@"
fi

if [[ $# -eq 3 ]]; then
	echo >&2 "No git path specified"
	help-git-submodule "$@"
fi

gh_bin=$(realpath "$1")
git_repo="$2"
git_branch="$3"
git_repo_dir=$(realpath "$4")
git_amend="$5"
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

#+begin_src bash :eval no :padline no
reset_xtrace
gh_token="${GITHUB_TOKEN}"
restore_xtrace
#+end_src

#+begin_src bash
# check paths
LAST_ERROR="gh binary not found"
[[ -f "${gh_bin}" ]] || $live_or_die
# check token
LAST_ERROR="authentication token is empty"
reset_xtrace
[[ -n "${gh_token}" ]] || $live_or_die
restore_xtrace
#+end_src

Authenticate.
#+begin_src bash
# authenticate with token
LAST_ERROR="authentication failed"
chmod u+x "${gh_bin}"
unset GITHUB_TOKEN
GIT_DIR=.nogit "${gh_bin}" auth login --git-protocol https --with-token <<< "${gh_token}" || $live_or_die
GIT_DIR=.nogit "${gh_bin}" auth setup-git || $live_or_die
#+end_src

#+begin_src bash
echo '::group::Update git submodules' | gh_echo
#+end_src

Update git submodules (on push event).
#+begin_src bash
# update git submodules
LAST_ERROR="git submodules update failed"
git clone -b "${git_branch}" "${git_repo}" "${git_repo_dir}" || $live_or_die
pushd "${git_repo_dir}"
git config --global --add safe.directory "${git_repo_dir}" || $live_or_die
git config user.name "git-submodule action"
git config user.email "nobody@nowhere"
git submodule update --init --force --remote --recursive
git add .
git commit ${git_amend:+--amend} --allow-empty -m "actions: update git submodules" \
	--author="git-submodule action <nobody@nowhere>" || $live_or_die
git push "origin" "${git_branch}" --force
popd
#+end_src

#+begin_src bash
echo '::endgroup::' | gh_echo
#+end_src

#+begin_src bash
echo '::notice::git submodules update ended!' | gh_echo
#+end_src

** Run

#+begin_src bash
<<common-variables>>
<<dockerfile-git-tasks>>
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

*** Run git tasks

**** Run script

#+begin_src bash
gh_bin="${SOURCE_PATH}"/cli/bin/gh
git_repo="https://github.com/ekotik/sh.wrap.git"
git_branch="gh-pages/test"
git_commands="git status
git log"
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 \
	GITHUB_TOKEN="${gh_token}" GITHUB_EVENT_NAME="push" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/git-tasks.sh "${gh_bin}" "${git_repo}" "${git_branch}" "${git_commands}"
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
	GITHUB_TOKEN="${gh_token}" GITHUB_EVENT_NAME="push" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/git-tasks.sh "${gh_bin}" "${git_repo}" "${git_branch}" "${git_commands}"
#+end_src

**** Run docker

#+begin_src bash
work_dir="/github/workspace"
script="${work_dir}"/src/git-tasks.sh
gh_bin=/go/gh
git_repo="https://github.com/ekotik/sh.wrap.git"
git_branch="gh-pages/test"
git_commands="git status
git log"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-git-tasks \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 \
	   -eGITHUB_TOKEN="${gh_token}" -eGITHUB_EVENT_NAME="push" \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${gh_bin}" "${git_repo}" "${git_branch}" "${git_commands}"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-git-tasks \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 -eLIVE_OR_DIE=live -eGH_MODE=1 \
	   -eGITHUB_TOKEN="${gh_token}" -eGITHUB_EVENT_NAME="push" \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
	   "${work_dir}" "${script}" "${gh_bin}" "${git_repo}" "${git_branch}" "${git_commands}"
#+end_src

**** Run action

***** Template

#+begin_src json :tangle ../../../test/workflow/data/git-tasks/01.json
{
  "ref": "${REF}",
  "inputs":
  {
    "run_id": "${RUN_ID}",
    "payload":
    {
      "dockerfile_template": "${DOCKERFILE_TEMPLATE}",
      "dockerfile": "${DOCKERFILE}",
      "work_dir": "${WORK_DIR}",
      "script": "${SCRIPT}",
      "gh_bin_source": "${GH_BIN_SOURCE}",
      "gh_bin_dest": "${GH_BIN_DEST}",
      "gh_bin_path": "${GH_BIN_PATH}",
      "gh_repo": "${GH_REPO}",
      "gh_hash": "${GH_HASH}",
      "gh_build_args": "${GH_BUILD_ARGS}",
      "git_repo": "${GIT_REPO}",
      "git_branch": "${GIT_BRANCH}",
      "git_commands": "${GIT_COMMANDS}"
    }
  }
}
#+end_src

***** Data

#+begin_src bash :tangle ../../../test/workflow/data/git-tasks/01/01.sh
#!/bin/bash
# shellcheck disable=SC2034

export WORKFLOW_ID="39712949"
export REF="actions"
export RUN_ID="git-tasks/01/01"
export DOCKERFILE_TEMPLATE="./_actions/docker/git-tasks.Dockerfile"
export DOCKERFILE="git-tasks.Dockerfile"
export WORK_DIR="/github/workspace"
export SCRIPT="./_actions/src/git-tasks.sh"
export GH_BIN_SOURCE="./cli/bin/gh"
export GH_BIN_DEST="/go/gh"
export GH_BIN_PATH="./cli/bin"
export GH_REPO="https://github.com/cli/cli"
export GH_HASH="7d71f807c48600d0d8d9f393ef13387504987f1d"
export GH_BUILD_ARGS=""
export GIT_REPO="https://github.com/ekotik/sh.wrap"
export GIT_BRANCH="gh-pages/test"
export GIT_COMMANDS="git status\\ngit log"
#+end_src

***** Test

#+begin_src bash
GITHUB_REPO="ekotik/sh.wrap"
env -i GITHUB_TOKEN="${gh_token}" \
    bash "${SOURCE_PATH}"/test/workflow/test-workflows.sh "${GITHUB_REPO}" "${SOURCE_PATH}"/test/workflow/data/git-tasks
#+end_src

*** Run gh publish

**** Run script

#+begin_src bash
gh_bin="${SOURCE_PATH}"/cli/bin/gh
gh_pages_repo="https://github.com/ekotik/sh.wrap.git"
gh_pages_branch="gh-pages/test"
public_dir="${SOURCE_PATH}"/test/hugo-site/site/public
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 \
	GITHUB_TOKEN="${gh_token}" GITHUB_EVENT_NAME="push" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/gh-publish.sh "${gh_bin}" "${gh_pages_repo}" "${gh_pages_branch}" "${public_dir}"
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
	GITHUB_TOKEN="${gh_token}" GITHUB_EVENT_NAME="push" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/gh-publish.sh "${gh_bin}" "${gh_pages_repo}" "${gh_pages_branch}" "${public_dir}"
#+end_src

**** Run docker

#+begin_src bash
work_dir="/github/workspace"
script="${work_dir}"/src/gh-publish.sh
gh_bin=/go/gh
gh_pages_repo="https://github.com/ekotik/sh.wrap.git"
gh_pages_branch="gh-pages/test"
public_dir="${work_dir}"/test/hugo-site/site/public
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-gh-publish \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 \
	   -eGITHUB_TOKEN="${gh_token}" -eGITHUB_EVENT_NAME="push" \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${gh_bin}" "${gh_pages_repo}" "${gh_pages_branch}" "${public_dir}"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-gh-publish \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 -eLIVE_OR_DIE=live -eGH_MODE=1 \
	   -eGITHUB_TOKEN="${gh_token}" -eGITHUB_EVENT_NAME="push" \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${gh_bin}" "${gh_pages_repo}" "${gh_pages_branch}" "${public_dir}"
#+end_src

**** Run action

***** Template

#+begin_src json :tangle ../../../test/workflow/data/gh-publish/01.json
{
  "ref": "${REF}",
  "inputs":
  {
    "run_id": "${RUN_ID}",
    "payload":
    {
      "dockerfile_template": "${DOCKERFILE_TEMPLATE}",
      "dockerfile": "${DOCKERFILE}",
      "work_dir": "${WORK_DIR}",
      "script": "${SCRIPT}",
      "gh_bin_source": "${GH_BIN_SOURCE}",
      "gh_bin_dest": "${GH_BIN_DEST}",
      "gh_bin_path": "${GH_BIN_PATH}",
      "gh_repo": "${GH_REPO}",
      "gh_hash": "${GH_HASH}",
      "gh_build_args": "${GH_BUILD_ARGS}",
      "gh_pages_repo": "${GH_PAGES_REPO}",
      "gh_pages_branch": "${GH_PAGES_BRANCH}",
      "public_dir": "${PUBLIC_DIR}",
      "public_cache": "${PUBLIC_CACHE}"
    }
  }
}
#+end_src

***** Data

#+begin_src bash :tangle ../../../test/workflow/data/gh-publish/01/01.sh
#!/bin/bash
# shellcheck disable=SC2034

export WORKFLOW_ID="37482756"
export REF="actions"
export RUN_ID="gh-publish/01/01"
export DOCKERFILE_TEMPLATE="./_actions/docker/git-tasks.Dockerfile"
export DOCKERFILE="git-tasks.Dockerfile"
export WORK_DIR="/github/workspace"
export SCRIPT="./_actions/src/gh-publish.sh"
export GH_BIN_SOURCE="./cli/bin/gh"
export GH_BIN_DEST="/go/gh"
export GH_BIN_PATH="./cli/bin"
export GH_REPO="https://github.com/cli/cli"
export GH_HASH="7d71f807c48600d0d8d9f393ef13387504987f1d"
export GH_BUILD_ARGS=""
export GH_PAGES_REPO="https://github.com/ekotik/sh.wrap"
export GH_PAGES_BRANCH="gh-pages/test"
export PUBLIC_DIR="./_actions/public"
export PUBLIC_CACHE="gh-publish-01-01"
#+end_src

***** Test

#+begin_src bash
GITHUB_REPO="ekotik/sh.wrap"
env -i GITHUB_TOKEN="${gh_token}" \
    bash "${SOURCE_PATH}"/test/workflow/test-workflows.sh "${GITHUB_REPO}" "${SOURCE_PATH}"/test/workflow/data/gh-publish
#+end_src

*** Run git submodules update

**** Run script

#+begin_src bash
gh_bin=$(realpath $(which gh))
git_repo="https://github.com/ekotik/ekotik.github.io"
git_branch="gh-pages/site"
git_path="./ekotik.github.io"
git_amend="yes"
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 \
	GITHUB_TOKEN="${gh_token}" GITHUB_EVENT_NAME="push" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/update-submodules.sh "${gh_bin}" "${git_repo}" "${git_branch}" "${git_path}" "${git_amend}"
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
	GITHUB_TOKEN="${gh_token}" GITHUB_EVENT_NAME="push" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/update-submodules.sh "${gh_bin}" "${git_repo}" "${git_branch}" "${git_path}" "${git_amend}"
#+end_src

**** Run docker

#+begin_src bash
work_dir="/github/workspace"
script="${work_dir}"/src/update-submodules.sh
gh_bin=/go/gh
git_repo="https://github.com/ekotik/ekotik.github.io"
git_branch="gh-pages/site"
git_path="./ekotik.github.io"
git_amend="yes"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-git-submodule \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 \
	   -eGITHUB_TOKEN="${gh_token}" -eGITHUB_EVENT_NAME="push" \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${gh_bin}" "${git_repo}" "${git_branch}" "${git_path}" "${git_amend}"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-git-submodule \
       --volume "${DOCKER_PATH}":"${work_dir}" \
	   -eLIVE_DEBUG=1 -eLIVE_OR_DIE=live -eGH_MODE=1 \
	   -eGITHUB_TOKEN="${gh_token}" -eGITHUB_EVENT_NAME="push" \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${gh_bin}" "${git_repo}" "${git_branch}" "${git_path}" "${git_amend}"
#+end_src

**** Run action

***** Template

#+begin_src json :tangle ../../../test/workflow/data/update-submodules/01.json
{
  "ref": "${REF}",
  "inputs":
  {
    "run_id": "${RUN_ID}",
    "payload":
    {
      "dockerfile_template": "${DOCKERFILE_TEMPLATE}",
      "dockerfile": "${DOCKERFILE}",
      "work_dir": "${WORK_DIR}",
      "script": "${SCRIPT}",
      "gh_bin_source": "${GH_BIN_SOURCE}",
      "gh_bin_dest": "${GH_BIN_DEST}",
      "gh_bin_path": "${GH_BIN_PATH}",
      "gh_repo": "${GH_REPO}",
      "gh_hash": "${GH_HASH}",
      "gh_build_args": "${GH_BUILD_ARGS}",
      "git_repo": "${GIT_REPO}",
      "git_branch": "${GIT_BRANCH}",
      "git_repo_dir": "${GIT_REPO_DIR}",
      "git_amend": "${GIT_AMEND}"
    }
  }
}
#+end_src

***** Data

#+begin_src bash :tangle ../../../test/workflow/data/update-submodules/01/01.sh
#!/bin/bash
# shellcheck disable=SC2034

export WORKFLOW_ID="38942440"
export REF="actions"
export RUN_ID="update-submodules/01/01"
export DOCKERFILE_TEMPLATE="./_actions/docker/git-tasks.Dockerfile"
export DOCKERFILE="git-tasks.Dockerfile"
export WORK_DIR="/github/workspace/_actions"
export SCRIPT="./src/update-submodules.sh"
export GH_BIN_SOURCE="./cli/bin/gh"
export GH_BIN_DEST="/go/gh"
export GH_BIN_PATH="./cli/bin"
export GH_REPO="https://github.com/cli/cli"
export GH_HASH="7d71f807c48600d0d8d9f393ef13387504987f1d"
export GH_BUILD_ARGS=""
export GIT_REPO="https://github.com/ekotik/sh.wrap"
export GIT_BRANCH="gh-pages/sh.wrap"
export GIT_REPO_DIR="sh.wrap"
export GIT_AMEND="yes"
#+end_src

***** Test

#+begin_src bash
GITHUB_REPO="ekotik/sh.wrap"
env -i GITHUB_TOKEN="${gh_token}" \
    bash "${SOURCE_PATH}"/test/workflow/test-workflows.sh "${GITHUB_REPO}" "${SOURCE_PATH}"/test/workflow/data/update-submodules
#+end_src

* Docker image for testing
  :PROPERTIES:
  :header-args: :results output verbatim silent wrap
  :header-args+: :noweb no-export
  :header-args+: :comments none
  :header-args+: :exports code
  :header-args+: :eval never-export
  :header-args:bash: :session *dockerfile-test-runner*
  :END:

#+call: tangle-dockerfiles()

** Build docker image

#+begin_src bash
<<common-variables>>
#+end_src

#+name: dockerfile-test-runner
#+begin_src bash
DOCKERFILE_TEMPLATE="${DOCKERFILES_PATH}"/test-runner.Dockerfile
DOCKER_IMAGE="test-runner:5.2"
DOCKER_PATH="${DOCKER_PATH}"
DOCKERFILE="${DOCKER_PATH}"/test-runner.Dockerfile
#+end_src

#+begin_src dockerfile :tangle ../../../docker/test-runner.Dockerfile :eval no
FROM bash:${BASH_DOCKER_VERSION} as build

RUN mkdir /te
COPY "${MICROSPEC_SOURCE}" "${MICROSPEC_DEST}"

FROM build as test-runner

COPY "${DOCKERFILE_SCRIPTS_PATH}"/entrypoint.sh /entrypoint.sh

ENTRYPOINT ["bash", "/entrypoint.sh"]
CMD ["${WORK_DIR}", "${SCRIPT}", "${MICROSPEC_PATH}", "${MICROSPEC_EXEC}", "${MICROSPEC_ARGS}"]
#+end_src

#+begin_src bash
env -i \
    DOCKERFILE_SCRIPTS_PATH="${DOCKERFILE_SCRIPTS_PATH}" \
	BASH_DOCKER_VERSION="5.2" \
	MICROSPEC_SOURCE="./test/microspec" \
    MICROSPEC_DEST="/te/microspec" \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/dockerfile.sh "${DOCKERFILE_TEMPLATE}" "${DOCKERFILE}"
#+end_src

#+begin_src bash :results code
docker build -t "${DOCKER_IMAGE}" -f "${DOCKERFILE}" "${DOCKER_PATH}" --no-cache
docker tag "${DOCKER_IMAGE}" "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

Push to Docker Hub (optionally).

#+begin_src bash :eval query
docker push "${DOCKER_REPO}"/"${DOCKER_IMAGE}"
#+end_src

** Run tests
   :PROPERTIES:
   :header-args:bash+: :tangle ../../../src/test-runner.sh
   :END:

#+begin_src bash :tangle no
<<common-variables>>
#+end_src

#+begin_src bash :tangle no
LIVE_OR_DIE=live
LIVE_DEBUG=1
#+end_src

#+begin_src bash :eval no
<<preamble>>

<<options>>

<<options-debug>>
#+end_src

#+begin_src bash
<<help>>

<<live-or-die-trap>>

<<gh-mode>>
#+end_src

Help.
#+begin_src bash
help-test-runner() {
	printf "Usage: %s: <MICROSPEC_PATH> <MICROSPEC_EXEC> [MICROSPEC_ARGS...]\n" "$0"
	help "$@"
}

echo '::notice::Test runner action started!' | gh_echo
#+end_src

Set up parameters.
#+begin_src bash :tangle no
shift $#
set -- "${SOURCE_PATH}"/test/microspec "microspec" "${SOURCE_PATH}/test/microspec/example.spec.sh"
#+end_src

Check parameters.
#+begin_src bash
# check parameters
if [[ $# -eq 0 ]]; then
	echo >&2 "No microspec path specified"
	help-test-runner "$@"
fi

if [[ $# -eq 1 ]]; then
	echo >&2 "No microspec executable specified"
	help-test-runner "$@"
fi

microspec_path=$(realpath "$1")
microspec_exec="$2"
shift 2
microspec="${microspec_path}"/"${microspec_exec}"
# shellcheck disable=SC2206
# intentional use of word splitting
microspec_args="$*"
#+end_src

#+begin_src bash
# check paths
LAST_ERROR="microspec executable not found"
[[ -f "${microspec}" ]] || $live_or_die
#+end_src

#+begin_src bash
echo '::group::Run tests | gh_echo'
#+end_src

Run tests.
#+begin_src bash
# run tests
LAST_ERROR="test running failed"
env -i bash -c "${microspec} ${microspec_args}" || $live_or_die
#+end_src

#+begin_src bash
echo '::endgroup::' | gh_echo
#+end_src

#+begin_src bash
echo '::notice::Test runner action ended!' | gh_echo
#+end_src

Exit.
#+begin_src bash :eval no
exit 0
#+end_src

** Run

#+begin_src bash
<<common-variables>>
<<dockerfile-test-runner>>
#+end_src

Authentication token for github.
#+begin_src bash :tangle no
read -s -p 'Enter token: ' gh_token
#+end_src

*** Run git tasks

**** Run script

#+begin_src bash
microspec_path="${SOURCE_PATH}"/test/microspec
microspec_exec="microspec"
microspec_args="${SOURCE_PATH}/test/microspec/example.spec.sh"
#+end_src

#+begin_src bash :eval query
env -i LIVE_DEBUG=1 \
    bash "${DOCKERFILE_SCRIPTS_PATH}"/test-runner.sh "${microspec_path}" "${microspec_exec}" "${microspec_args}"
#+end_src

#+begin_src bash :eval query
env LIVE_DEBUG=1 LIVE_OR_DIE=live GH_MODE=1 \
	bash "${DOCKERFILE_SCRIPTS_PATH}"/test-runner.sh "${microspec_path}" "${microspec_exec}" "${microspec_args}"
#+end_src

**** Run docker

#+begin_src bash
work_dir="/github/workspace"
script="${work_dir}"/src/test-runner.sh
microspec_path="${work_dir}"/test/microspec
microspec_exec="microtap"
microspec_args="${work_dir}/test/microspec/example.spec.sh"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-git-tasks \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${microspec_path}" "${microspec_exec}" "${microspec_args}"
#+end_src

#+begin_src bash :eval query
docker run -it --rm --name shwrap-git-tasks \
       --volume "${DOCKER_PATH}":"${work_dir}" \
       -eLIVE_DEBUG=1 -eLIVE_OR_DIE=live -eGH_MODE=1 \
       "${DOCKER_REPO}"/"${DOCKER_IMAGE}" \
       "${work_dir}" "${script}" "${microspec_path}" "${microspec_exec}" "${microspec_args}"
#+end_src

**** Run action

***** Template

#+begin_src json :tangle ../../../test/workflow/data/test-runner/01.json
{
  "ref": "${REF}",
  "inputs":
  {
    "run_id": "${RUN_ID}",
    "payload":
    {
      "dockerfile_template": "${DOCKERFILE_TEMPLATE}",
      "dockerfile": "${DOCKERFILE}",
      "work_dir": "${WORK_DIR}",
      "script": "${SCRIPT}",
      "bash_docker_version": "${BASH_DOCKER_VERSION}",
      "microspec_source": "${MICROSPEC_SOURCE}",
      "microspec_dest": "${MICROSPEC_DEST}",
      "microspec_exec": "${MICROSPEC_EXEC}",
      "microspec_args": "${MICROSPEC_ARGS}"
    }
  }
}
#+end_src

***** Data

#+begin_src bash :tangle ../../../test/workflow/data/test-runner/01/01.sh
#!/bin/bash
# shellcheck disable=SC2034

export WORKFLOW_ID="45055402"
export REF="actions"
export RUN_ID="test-runner/01/01"
export DOCKERFILE_TEMPLATE="./_actions/docker/test-runner.Dockerfile"
export DOCKERFILE="test-runner.Dockerfile"
export WORK_DIR="/github/workspace/_actions"
export SCRIPT="./src/test-runner.sh"
export BASH_DOCKER_VERSION="5.2"
export MICROSPEC_SOURCE="./test/microspec"
export MICROSPEC_DEST="/te/microspec"
export MICROSPEC_EXEC="microspec"
export MICROSPEC_ARGS=""
#+end_src

***** Test

#+begin_src bash
GITHUB_REPO="ekotik/sh.wrap"
env -i GITHUB_TOKEN="${gh_token}" \
    bash "${SOURCE_PATH}"/test/workflow/test-workflows.sh "${GITHUB_REPO}" "${SOURCE_PATH}"/test/workflow/data/test-runner
#+end_src
